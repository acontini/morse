#include <stdio.h>
#include <netdb.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>

#define PSIZE 1500
#define PLEN_DASH 300
#define PLEN_DOT 100
#define PLEN_CSPACE 10
#define PLEN_WSPACE 15
#define PLEN_TERM 400

struct xtab_struct
{
  char c;
  char *x;
} xtab[]=
  {
    {'"', ".-..-."},
    {'\'', ".----."},
    {'(', "-.--.-"},
    {')', "-.--.-"},
    {',', "--..--"},
    {'-', "-....-"},
    {'.', ".-.-.-"},
    {'/', "-..-."},
    {'0', "-----"},
    {'1', ".----"},
    {'2', "..---"},
    {'3', "...--"},
    {'4', "....-"},
    {'5', "....."},
    {'6', "-...."},
    {'7', "--..."},
    {'8', "---.."},
    {'9', "----."},
    {':', "---..."},
    {'?', "..--.."},
    {'A', ".-"},
    {'B', "-..."},
    {'C', "-.-."},
    {'D', "-.."},
    {'E', "."},
    {'F', "..-."},
    {'G', "--."},
    {'H', "...."},
    {'I', ".."},
    {'J', ".---"},
    {'K', "-.-"},
    {'L', ".-.."},
    {'M', "--"},
    {'N', "-."},
    {'O', "---"},
    {'P', ".--."},
    {'Q', "--.-"},
    {'R', ".-."},
    {'S', "..."},
    {'T', "-"},
    {'U', "..-"},
    {'V', "...-"},
    {'W', ".--"},
    {'X', "-..-"},
    {'Y', "-.--"},
    {'Z', "--.."},
    {'Ä', ".-.-"},
    {'Å', ".--.-"},
    {'Ö', "---."},
    {'Á', ".--.-"},
    {'É', "..-.."},
    {'Ñ', "--.--"},
    {'Ü', "..--"}
  };

#define NCODES (sizeof(xtab)/sizeof(struct xtab_struct))

struct morse_packet
{
  unsigned long seq;
};

/* Translate an ASCII hostname or ip address to a struct in_addr - return 0
   if unable */
int makeaddress(char *name_or_ip, struct in_addr *res)
{
  struct hostent *he;
  if (!inet_aton(name_or_ip,res))
    {
      if (!(he=gethostbyname(name_or_ip)))
	return 0;
      else
	{
	  memcpy(res, he->h_addr_list[0], sizeof(res));
	  return 1;
	}
    }
  else
    return 1;
}

void printword(char *mword)
{
  int i;
  for (i=0; i<NCODES; i++)
    {
      if (!strcmp(xtab[i].x,mword))
	{
	  putchar(xtab[i].c);
	  break;
	}
      else
	putchar('~');
    }
  mword[0]='\0';
}

#define BUFSIZE 131072

unsigned long collapse_rcvbuf(char buf, char *mword, unsigned long seqno)
{
  int i;
  char current_bit, stmp[2];
  for (i=0; (i<BUFSIZE) && (current_bit=buf[i])!='\0'; i++)
  {
    if ((current_bit==' ') || (current_bit=='+') || (current_bit=='/'))
      {
	printword(mword);
	if (current_bit==' ')
	  putchar(' ');
	if (current_bit=='/')
	  {
	    do_timeout(rcvbuf, seqno);
	    seqno=0;
	  }
	else
	  seqno++;
      }
    else
      {
	stmp[0]=current_bit;
	stmp[1]='\0';
	strcat(mword,stmp);
	seqno++;
      }
  }
  if (i>0)
    {
      memcpy(buf,&(buf[i]),BUFSIZE-i);
      memset(&(buf[BUFSIZE-i]),'\0',i);
    }
  return seqno;
}

void do_timeout(char buf, char *mword, unsigned long seqno)
{
  
}

int main(int argc, char *argv[])
{
  int sock;
  struct protoent *p;
  char mypacket[PSIZE];
  static char rcvbuf[BUFSIZE];
  struct morse_packet *mpack=(struct morse_packet *)(mypacket+20);
  unsigned long seqno=0;
  int i, j, k;
  char *mcode;
  struct sockaddr_in sender, from;
  fd_set myfdset;
  struct timeval select_timeout;
  int ready;
  int alen;
  int len;
  char current_bit;
  char mword[512],stmp[2];

  for (i=0;i<BUFSIZE;i++)
    rcvbuf[i]='\0';
  if (argc<2)
    {
      fprintf(stderr, "Usage: %s <sender> <text> ...\n", argv[0]);
      return -1;
    }
  memset(&sender, 0, sizeof(sender));
  sender.sin_family=AF_INET;
  if (!makeaddress(argv[1], &sender.sin_addr))
    {
      perror(argv[1]);
      return -2;
    }
  if (!(p=getprotobyname("morse")))
    {
      perror("morse");
      return -1;
    }
  if ((sock=socket(AF_INET, SOCK_RAW, p->p_proto))<0)
    {
      perror("socket()");
      return -2;
    }
  ready=0;
  mword[0]='\0';
  while (!ready)
    {
      select_timeout.tv_sec=1;
      select_timeout.tv_usec=0;
      FD_ZERO(&myfdset);
      FD_SET(sock,&myfdset);
      if (select(sock+1, &myfdset, NULL, NULL, &select_timeout))
	{
	  alen=sizeof(from);
	  len=recvfrom(sock, mypacket, sizeof(mypacket), 0, (struct sockaddr *)&from, &alen);
	  if (!memcmp(&(from.sin_addr), &(sender.sin_addr), sizeof(from.sin_addr)))
	    {
	      switch (len - 20)
		{
		case PLEN_DASH:
		  current_bit='-';
		  break;
		case PLEN_DOT:
		  current_bit='.';
		  break;
		case PLEN_WSPACE:
		  current_bit=' ';
		  break;
		case PLEN_CSPACE:
		  current_bit='+';
		  break;
		case PLEN_TERM:
		  current_bit='/';
		  break;
		default:
		  printf("len=%d ", len);
		  break;
		}
	      if (ntohl(mpack->seq)==seqno)
		{
		  if ((current_bit==' ') || (current_bit=='+') || (current_bit=='/'))
		    printword(mword);
		  else
		    {
		      stmp[0]=current_bit;
		      stmp[1]='\0';
		      strcat(mword,stmp);
		    }
		  if (current_bit==' ')
		    putchar(' ');
		  if (current_bit=='/')
		    {
		      do_timeout(rcvbuf, seqno);
		      seqno=0;
		    }
		  else
		    seqno++;
		  fflush(stdout);
		}
	      else
		{
		  if (mpack->seq>seqno)
		    {
		      if (mpack->seq - seqno > BUFSIZE)
			{
			  do_timeout(rcvbuf,seqno);
			  seqno=mpack->seq;
			}
		      rcvbuf[mpack->seq - seqno]=current[bit];
		      seqno=collapse_rcvbuf(rcvbuf,mword,seqno);
		    }
		}
	    }
	  else
	    printf("Wrong sender %s != %s\n", inet_ntoa(from.sin_addr), 
		   inet_ntoa(sender.sin_addr));
	}
      else
	{
	  /*	  if (strlen(mword))
	    {
	    printword(mword);
	      putchar('\n');
	      fflush(stdout);
	    }*/
	}
    }
  close(sock);
}
